<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>three.js</title>
		<style>
			body { margin: 0; background-color: #181818; overflow: hidden; color: #fff; }
			canvas { width: 100%; height: 100% };
			a { color: #ffffff; }
			#oldie a { color:#da0 }
			#info {
				text-align: center;
				padding: 10px;
				z-index: 100;
				width: 100%;
				position: absolute;
			}
		</style>
	</head>
	<body>

		<!-- where the content goes -->
		<div id="container">
			<div id="info">Camera: click and drag to rotate, mousewheel to zoom - Shift+click to drop cubes</div>
		</div>

		<!-- javascript libs at the end -->
		<script src="jquery-1.8.2.min.js"></script>
		<script src="three.min.js"></script>
		<script src="Detector.js"></script>
		<script src="stats.min.js"></script>
		<script src="OrbitControls.js"></script>
		<script src="physi.js"></script>

		<!-- rendering -->
		<script>
			'use strict';

			Physijs.scripts.worker = 'physijs_worker.js';
			Physijs.scripts.ammo = 'ammo.js';

			// set the scene size
			var WIDTH = window.innerWidth,
			  HEIGHT = window.innerHeight;

			// set some camera attributes
			var VIEW_ANGLE = 45,
			  ASPECT = WIDTH / HEIGHT,
			  NEAR = 0.1,
			  FAR = 10000;

			// get the DOM element to attach to
			var container = $('#container');
			var renderer, camera, scene, controls, stats, projector, ray, plane, isShiftDown = false;

			var mouse = new THREE.Vector3( 0, 0, 0.5 ); // Mouse position

			////////////////////////////////////////////////////////////////////////////////////////////

			// Can we start?
			if (!Detector.webgl){
				Detector.addGetWebGLMessage();

				if (Detector.canvas){
					window.setTimeout(Detector.removeGetWebGLMessage, 5000);
					window.setTimeout(init, 5500);
				}
				return;
			}
			else{
				init();
			}

			////////////////////////////////////////////////////////////////////////////////////////////

			// Init and start
			function init(){
				// create a WebGL renderer, camera
				// and a scene
				if (Detector.webgl){
					renderer = new THREE.WebGLRenderer({
						antialias: true,
						preserveDrawingBuffer   : true  // required to support .toDataURL()
					});

					renderer.setFaceCulling("back");

					// shadowing
					renderer.shadowMapEnabled = true;
					renderer.shadowMapSoft = true; // to antialias the shadow
				}
				else if (Detector.canvas){
					renderer = new THREE.CanvasRenderer();
				}

				renderer.setClearColorHex(0x181818);
				window.addEventListener( 'resize', onWindowResize, false ); // handle resizing
				
				// stop the user getting a text cursor
				// http://www.aerotwist.com/tutorials/ten-things-i-learned/
				document.onselectstart = function(){ return false; };

				// Camera
				camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
				projector = new THREE.Projector();

				scene = new Physijs.Scene;
				scene.setGravity(new THREE.Vector3(0, -30, 0));

				// add the camera to the scene
				scene.add(camera);

				// the camera starts at 0,0,0, so pull it back
				camera.position.z = 300;

				// start the renderer
				renderer.setSize(WIDTH, HEIGHT);

				// attach the render-supplied DOM element
				container.append(renderer.domElement);

				// STATS
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				container.append( stats.domElement );

				stats.domElement.children[ 0 ].children[ 0 ].style.color = "#aaa";
				stats.domElement.children[ 0 ].style.background = "transparent";
				stats.domElement.children[ 0 ].children[ 1 ].style.display = "none";

				// Set everything else up
				setupControls();
				setupObjects();
				setupLights();

				// Start rendering!
				render();
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				render();

			}

			////////////////////////////////////////////////////////////////////////////////////////////

			function setupControls(){
				// Camera controls
				controls = new THREE.OrbitControls( camera );
				controls.userZoomSpeed = 0.3;

				// Other keyboard controls
				document.addEventListener('keydown', function(event){
					if (event.altKey){
						return;
					}

					//event.preventDefault();

					switch (event.keyCode){

						case 80: /* P */
							// http://learningthreejs.com/blog/2011/09/03/screenshot-in-javascript/
							var dataUrl = renderer.domElement.toDataURL("image/png");
							window.open(dataUrl, '_screenshot');
							break;
						case 16: /* shift */
							isShiftDown = true;
							break;
					}
				},
				false);

				document.addEventListener('keyup', function(event){
					if (event.altKey){
						return;
					}

					//event.preventDefault();

					switch (event.keyCode){

						case 16: /* shift */
							isShiftDown = false;
							break;
					}
				},
				false);

				// Other mouse controls
				document.addEventListener('mousedown', function(event){

					event.preventDefault();

					// Spawn a cube where we click
					if (event.button === 0 && isShiftDown){
						ray = projector.pickingRay(mouse.clone(), camera);

						var intersects = ray.intersectObjects(scene.children);
						console.log('intersects', intersects);
						for (var i = 0; i < intersects.length; i++){

							var intersector = intersects[i];

							if (intersector.object == plane){

								console.log("Cube spawned", intersector.point.x, intersector.point.y, intersector.point.z);
								var spawnedCube = new Physijs.BoxMesh(new THREE.CubeGeometry(25, 25, 25), new THREE.MeshLambertMaterial({color: 0x0000ff}), undefined, { restitution: .2 });
								spawnedCube.position.x = intersector.point.x;
								spawnedCube.position.y = intersector.point.y;
								spawnedCube.position.y = 100;
								spawnedCube.castShadow = true;
								spawnedCube.receiveShadow  = true;
								scene.add(spawnedCube);
							}

						}
					}
				},
				false);

				document.addEventListener('mousemove', function(event){

					event.preventDefault();

					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
					mouse.z = 0;

					//console.log('Mouse move', mouse.x, mouse.y, mouse.z);
				},
				false);
			}

			////////////////////////////////////////////////////////////////////////////////////////////

			var sphere, cube, ground;
			function setupObjects(){
				// set up the sphere vars
				var radius = 25,
				    segments = 32,
				    rings = 32;

				// create the sphere's material
				var sphereMaterial =
				  new THREE.MeshLambertMaterial(
				    {
				      color: 0xCC0000
				    });

				// create a new mesh with
				// sphere geometry
				sphere = new Physijs.SphereMesh(

				  new THREE.SphereGeometry(
				    radius,
				    segments,
				    rings),

				  sphereMaterial,

				  0 // 0 mass, so it doesn't move
				);

				// shadows
				sphere.castShadow = true;
				sphere.receiveShadow  = true;

				// add the sphere to the scene
				sphere.position.x = -50;
				scene.add(sphere);

				// Add a cube
				var cubeGeometry = new THREE.CubeGeometry(25, 25, 25);
				var cubeMaterial = new THREE.MeshLambertMaterial({color: 0x0000ff});
				cube = new Physijs.BoxMesh(cubeGeometry, cubeMaterial, undefined, { restitution: .2 });
				cube.position.x = 50;
				cube.castShadow = true;
				cube.receiveShadow  = true;
				scene.add(cube);

				// Ground
				var ground_material = Physijs.createMaterial(
					new THREE.MeshLambertMaterial({color: 0x249E24}),
					.8, // high friction
					.4 // low restitution
				);

				ground = new Physijs.BoxMesh(
					new THREE.CubeGeometry(1000, 1, 1000),
					//new THREE.PlaneGeometry(50, 50),
					ground_material,
					0 // mass
				);
				ground.position.y = -50;
				ground.receiveShadow = true;
				scene.add( ground );

				plane = new THREE.Mesh( new THREE.PlaneGeometry( 1000, 1000, 1, 1 ), new THREE.MeshBasicMaterial( { visible: false } ) );
				scene.add( plane );
			}

			////////////////////////////////////////////////////////////////////////////////////////////

			function setupLights(){
				// create a directional light
				var light = new THREE.DirectionalLight(0xFFFFFF);

				// set its position
				light.position.x = 20;
				light.position.y = 40;
				light.position.z = 15;

				// shadows
				// http://learningthreejs.com/blog/2012/01/20/casting-shadows/
				light.castShadow = true;
				light.shadowCameraLeft = -60;
				light.shadowCameraTop = -60;
				light.shadowCameraRight = 60;
				light.shadowCameraBottom = 60;
				light.shadowCameraNear = 20;
				light.shadowCameraFar = 200;
				light.shadowBias = -.0001
				light.shadowMapWidth = light.shadowMapHeight = 2048;
				light.shadowDarkness = .7;

				light.target.position.copy( scene.position );

				// add to the scene
				scene.add(light);

				//var ambientLight = new THREE.AmbientLight( 0x606060 );
				//scene.add( ambientLight );
			}

			////////////////////////////////////////////////////////////////////////////////////////////
			
			// draw!
			function render(){
				requestAnimationFrame(render); // 60fps, but pauses if we tab away

				stats.update(); // update stats

				scene.simulate(); // run physics

				controls.update(); // controls

				// Spin the sphere
				sphere.rotation.y += 0.01;
				sphere.__dirtyRotation = true; // we moved the sphere manually, so let the simulation know

				renderer.render(scene, camera);
			}

			////////////////////////////////////////////////////////////////////////////////////////////
		</script>
	</body>
</html>